/*
template <typename T>
struct is_std_array : std::false_type {};

template <typename T, std::size_t N>
struct is_std_array<std::array<T, N>> : std::true_type {};

template <typename T>
inline constexpr bool is_std_array_v = is_std_array<T>::value;
*/
/*
is_std_array: <T> type = {
    this: std::false_type;
}

Array: <T, N: std::size_t> type = {
    this: std::array<T, N>;
}

is_std_array: <T: Array> type = {
    this: std::true_type;
}

is_std_array_v: <T> type == is_std_array<T>::value;
*/

nxs: namespace = {
detail: namespace = {

// Template meta-programming / meta-functions
meta: namespace = {

_iterator: <Container> type = {
    value: type == Container::iterator;
}

_const_iterator: <Container> type = {
    value: type == Container::const_iterator;
}

_reverse_iterator: <Container> type = {
    value: type == Container::reverse_iterator;
}

_const_reverse_iterator: <Container> type = {
    value: type == Container::const_reverse_iterator;
}

} // namespace meta

flat_map_iterator: <ContainerType, Iterators> type = {
    self             : type == flat_map_iterator<ContainerType, Iterators>;

    value_type       : type == ContainerType::value_type;
    pointer          : type == ContainerType::pointer;
    reference        : type == ContainerType::reference;
    difference_type  : type == std::ptrdiff_t;

    iterator_category: type == std::random_access_iterator_tag;

    operator=: (out this, iter: Iterators) = {
        _iter = iter;
    }

/*
    constexpr self& operator++() noexcept {
        ++_iter.key;
        ++_iter.value;
        return *this;
    }

    [[nodiscard]] constexpr self& operator++(int) noexcept {
        self iter = *this;
        ++(*this);
        return iter;
    }

    constexpr self& operator--() noexcept {
        --_iter.key;
        --_iter.value;
        return *this;
    }

    [[nodiscard]] constexpr self& operator--(int) noexcept {
        self iter = *this;
        --(*this);
        return iter;
    }
*/

    operator+: (this, n: difference_type) -> self = {
        return Iterators(_iter.key + n, _iter.value + n);
    }

    operator+=: (this, n: difference_type) -> self = {
        iter: self = this;
        iter = iter + n;
        return iter;
    }

    operator-: (this, that) -> difference_type = {
        return _iter.key - that._iter.key;
    }

    operator*: (this) -> reference = {
        return std::make_shared(std::ref(_iter.key*), std::ref(_iter.value*));
    }

    operator==: (this, that) -> bool = _iter == that._iter;
    operator!=: (this, that) -> bool = !(this == that);

    key  : (this) -> _ = _iter.key;
    value: (this) -> _ = _iter.value;

    private _iter: Iterators;
}

} // namespace detail

flat_map: <Key, T, Compare, KeyContainer, MappedContainer> type = {
/*
    template <template <typename> typename MetaFunc>
    struct iterators {
        using key_iterator = typename MetaFunc<KeyContainer>::value;
        using value_iterator = typename MetaFunc<MappedContainer>::value;

        auto operator<=>(const iterators&) const = default;

        key_iterator key;
        value_iterator value;
    };
*/
/*
    // TODO: template-template is not a valid syntax?
    private iterators: < <> MetaFunc> type = {
        key_iterator  : type == MetaFunc<KeyContainer>::value;
        value_iterator: type == MetaFunc<MappedContainer>::value;

        operator<=>: (this, that) -> std::strong_ordering;

        key  : key_iterator;
        value: value_iterator;
    }
*/

    self                 : type == flat_map<Key, T, Compare, KeyContainer, MappedContainer>;

    key_type             : type == Key;
    mapped_type          : type == T;
    key_compare          : type == Compare;

    size_type            : type == std::size_t;
    difference_type      : type == std::ptrdiff_t;
/*
    iterator_pair              : type == iterators<detail::meta::_iterator>;
    const_iterator_pair        : type == iterators<detail::meta::_const_iterator>;
    reverse_iterator_pair      : type == iterators<detail::meta::_reverse_iterator>;
    const_reverse_iterator_pair: type == iterators<detail::meta::_const_reverse_iterator>;

    iterator              : type == detail::flat_map_iterator<self, iterator_pair>;
    const_iterator        : type == detail::flat_map_iterator<self, const_iterator_pair>;
    reverse_iterator      : type == detail::flat_map_iterator<self, reverse_iterator_pair>;
    const_reverse_iterator: type == detail::flat_map_iterator<self, const_reverse_iterator_pair>;
*/
    key_container_type   : type == KeyContainer;
    mapped_container_type: type == MappedContainer;
/*
    constexpr flat_map(std::initializer_list<value_type> ilist) {
        range_initialize(std::begin(ilist), std::end(ilist));
    }

    // TODO: Not working
    operator=: (out this, ilist: std::initializer_list<value_type>) = {
        range_initialize(std::begin(ilist), std::end(ilist));
    }
*/
    empty : (this) -> _                             = _keys.empty();
    size  : (this) -> _                             = _keys.size();
    keys  : (this) -> forward key_container_type    = _keys;
    values: (this) -> forward mapped_container_type = _values;

/*
    [[nodiscard]] constexpr mapped_type& at(const key_type& key) const noexcept {
        const auto keyEqual = [&key](const auto& ref) { return key == ref.first; };
        const auto iter = std::find_if(begin(), end(), keyEqual);

        return *iter.value();
    }
*/
/*
    at: (key: key_type) -> forward mapped_type = {
        keyEqual: const _ = :(ref) -> _ = key$ == ref.first;
        iter: const _ = std::find_if(begin(), end(), keyEqual);

        // return iter*.value();
    }
*/

/*
    constexpr std::pair<iterator, bool> insert(const std::pair<Key, T>& value) {
        const auto keyEqual = [&value](const auto& ref) { return value.first == ref.first; };
        auto iter = std::find_if(begin(), end(), keyEqual);

        if (iter != end()) {
            return { iter, false };
        }

        auto key_iter = std::upper_bound(std::begin(_keys), std::end(_keys), value.first, Compare());
        key_iter = _keys.insert(key_iter, value.first);

        const auto value_iter = _values.insert(
            std::next(std::begin(_values), std::distance(std::begin(_keys), key_iter)),
            value.second
        );

        return { iterator_pair{ key_iter, value_iter }, true };
    }
*/
/*
    insert: (value: std::pair<Key, T>) -> std::pair<iterator, bool> = {
        keyEqual: const _ = :(ref) -> _ = value.first == ref.first;
        iter: _ = std::find_if(begin(), end(), keyEqual);

        if iter != end() {
            return (iter, false);
        }

        key_iter: _ = std::upper_bound(std::begin(_keys), std::end(_keys), value.first, Compare());
        key_iter = _keys.insert(key_iter, value.first);

        value_iter: const _ = _values.insert(
            std::next(std::begin(_values), std::distance(std::begin(_keys), key_iter)),
            value.second
        );

        return (iterator_pair(key_iter, value_iter), true);
    }
*/

/*
    [[nodiscard]] constexpr mapped_type& operator[](const key_type& key) {
        const auto keyEqual = [&key](const auto& ref) { return key == ref.first; };
        const auto iter = std::find_if(begin(), end(), keyEqual);

        if (iter == end()) {
            const auto& [inserted, _] = insert({ key, T{} });
            return *inserted.value();
        }

        return *iter.value();
    }
*/
/*
    operator[]: (key) -> forward mapped_type = {
        keyEqual: const _ = :(ref) -> _ = key$ == ref.first;
        iter: const _ = std::find_if(begin(), end(), keyEqual);

        if iter == end() {
            inserted: const _ = insert((key, T()));
            first: const _ = inserted.first;
            // return first*.value();
        }

        // return iter*.value();
    }
*/

/*
    begin: (this) -> iterator = {
        return iterator_pair(std::begin(_keys), std::begin(_values));
    }

    end  : (this) -> iterator = {
        return iterator_pair(std::end(_keys), std::end(_values));
    }

    begin: (this) -> const_iterator = {
        return const_iterator_pair(std::begin(_keys), std::begin(_values));
    }

    end  : (this) -> const_iterator = {
        return const_iterator_pair(std::end(_keys), std::end(_values));
    }

    cbegin: (this) -> const_iterator = {
        return const_iterator_pair(std::cbegin(_keys), std::cbegin(_values));
    }

    cend  : (this) -> const_iterator = {
        return const_iterator_pair(std::cend(_keys), std::cend(_values));
    }

    rbegin: (this) -> reverse_iterator = {
        return reverse_iterator_pair(std::rbegin(_keys), std::rbegin(_values));
    }

    rend: (this) -> reverse_iterator = {
        return reverse_iterator_pair(std::rend(_keys), std::rend(_values));
    }

    rbegin: (this) -> const_reverse_iterator = {
        return const_reverse_iterator_pair(std::rbegin(_keys), std::rbegin(_values));
    }

    rend: (this) -> const_reverse_iterator = {
        return const_reverse_iterator_pair(std::rend(_keys), std::rend(_values));
    }

    crbegin: (this) -> const_reverse_iterator = {
        return const_reverse_iterator_pair(std::crbegin(_keys), std::crbegin(_values));
    }

    crend: (this) -> const_reverse_iterator = {
        return const_reverse_iterator_pair(std::crend(_keys), std::crend(_values));
    }
*/
    private _keys  : key_container_type;
    private _values: mapped_container_type;

/*
    private range_initialize: <Iter> (this, copy first: Iter, copy last: Iter) = {
        // TODO: is_std_array_v
        if is_std_array_v<key_container_type> {
            index: std::size_t = 0;
            while first != last next first++ {
                _keys[index] = first*.first;
                _values[index] = first*.second;
                index++;
            }
        } else {
            while first != last next first++ {
                _keys.push_back(first*.first);
                _values.push_back(first*.second);
            }
        }
    }
*/
}

static_map: <Key, T, Capacity: std::size_t> type
    == flat_map<Key, T, std::less<Key>, std::array<Key, Capacity>, std::array<T, Capacity>>;

} // namespace nxs

main:() = {
    dMap: nxs::flat_map<int, std::string, std::less<int>, std::vector<int>, std::vector<std::string>> = ();
    // sMap: nxs::static_map<int, int, 2> = (std::pair(1, 2), std::pair(3, 4));

    std::puts("Hello world");
}
